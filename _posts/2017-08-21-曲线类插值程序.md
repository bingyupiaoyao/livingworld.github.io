# 20170821-曲线类插值程序
## 版本一(推荐)
- Curveclass.cs
```
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WindowsFormsApplication1
{
    class Curveclass
    {
        private int Rnum;
        private int[] Node_VZ;
        private int[] Node_QZ;
        private double[][] Cur_VZ_V;
        private double[][] Cur_VZ_Z;
        private double[][] Cur_QZ_Q;
        private double[][] Cur_QZ_Z;

        public DataTable GetDataTable(string str)
        {
            //string constr = "server=./LENOVO-PC/SQLEXPRESS;Uid=water;pwd=3234347;database=gxherolj;";
            string constr = @"server=.\SQLEXPRESS;Uid=water;pwd=3234347;database=gxherolj;";
            SqlConnection con = new SqlConnection(constr);
            SqlDataAdapter DA = new SqlDataAdapter(str, con);
            DataTable dt = new DataTable();
            DA.Fill(dt);
            con.Close();
            return dt;
        }

        //利用切片返回多个不同类型数值，考虑一次性将四座水库水位库容关系数值存储于数组中。
        public Tuple<double[], double[], int> get_vz(int RSCD)
        {

            DataTable dt = GetDataTable("SELECT [RZ],[RV] FROM RS_ZVARL_B WHERE RSCD = '" + RSCD + "'ORDER BY PTNO");
            int Node = dt.Rows.Count;
            double[] Cur_V = new double[Node];
            double[] Cur_Z = new double[Node];
            for (int i = 0; i < Node; i++)
            {
                Cur_V[i] = Convert.ToDouble(dt.Rows[i]["RV"]);
                Cur_Z[i] = Convert.ToDouble(dt.Rows[i]["RZ"]);
            }
            var result = Tuple.Create(Cur_V, Cur_Z, Node);
            return result;
        }
        public Tuple<double[], double[], int> get_qz(int RSCD)
        {

            DataTable dt = GetDataTable("SELECT [RZ],[RSWQ],[RECQ],[RQ] FROM RS_DCCP_B WHERE RSCD = '" + RSCD + "'ORDER BY PTNO");
            int Node = dt.Rows.Count;
            double[] Cur_Q = new double[Node];
            //double[] Cur_RSWQ = new double[Node];//作为展示，针对青狮潭水库泄流是由溢洪道和发电洞构成，但水位对应有唯一的流量和，故单独考虑时只是作为chart展示
            //double[] Cur_RECQ = new double[Node];
            double[] Cur_Z = new double[Node];
            for (int i = 0; i < Node; i++)
            {
                //Cur_RSWQ[i] = Convert.ToDouble(dt.Rows[i]["RSWQ"]);
                //Cur_RECQ[i] = Convert.ToDouble(dt.Rows[i]["RECQ"]);
                Cur_Q[i] = Convert.ToDouble(dt.Rows[i]["RQ"]);
                Cur_Z[i] = Convert.ToDouble(dt.Rows[i]["RZ"]);
            }
            var result = Tuple.Create(Cur_Q, Cur_Z, Node);
            return result;
        }
        public void Set_Reservoirs_Num(int reservoirs_num)
        {
            Rnum = reservoirs_num;
            Cur_VZ_V = new double[Rnum][];
            Cur_VZ_Z = new double[Rnum][];
            Cur_QZ_Q = new double[Rnum][];
            Cur_QZ_Z = new double[Rnum][];
            Node_VZ = new int[Rnum];
            Node_QZ = new int[Rnum];
        }
        public void Set_VZ(int Rindex, int Point, double[] V, double[] Z)
        {
            Cur_VZ_V[Rindex] = V;
            Cur_VZ_Z[Rindex] = Z;
            Node_VZ[Rindex] = Point;
        }
        public void Set_QZ(int Rindex, int Point, double[] Q, double[] Z)
        {
            Cur_QZ_Q[Rindex] = Q;
            Cur_QZ_Z[Rindex] = Z;
            Node_QZ[Rindex] = Point;
        }

        //volume => water level
        public double insert_vv_zz(int Rindex,double vStar)
        {
            double zStar = 0;

            for (int i = 0; i <= Node_VZ[Rindex] - 2; i++)
            {
                if (vStar < Cur_VZ_V[Rindex][0])
                {
                    vStar = Cur_VZ_V[Rindex][0];
                }
                else if (vStar > Cur_VZ_V[Rindex][Node_VZ[Rindex] - 1])
                {
                    vStar = Cur_VZ_V[Rindex][Node_VZ[Rindex] - 1];
                }
                if ((vStar >= Cur_VZ_V[Rindex][i]) && (vStar <= Cur_VZ_V[Rindex][i + 1]))
                {
                    zStar = (vStar - Cur_VZ_V[Rindex][i]) * (Cur_VZ_Z[Rindex][i + 1] - Cur_VZ_Z[Rindex][i]) / (Cur_VZ_V[Rindex][i + 1] - Cur_VZ_V[Rindex][i]) + Cur_VZ_Z[Rindex][i];
                    break;
                }
            }
            return zStar;
        }
        //water level => volume
        public double insert_zz_vv(int Rindex, double zStar)
        {
            double vStar = 0;
            for (int i = 0; i <= Node_VZ[Rindex] - 2; i++)
            {
                if (zStar < Cur_VZ_Z[Rindex][0])
                {
                    zStar = Cur_VZ_Z[Rindex][0];
                }
                else if (zStar > Cur_VZ_Z[Rindex][Node_VZ[Rindex] - 1])
                {
                    zStar = Cur_VZ_Z[Rindex][Node_VZ[Rindex] - 1];
                }
                if ((zStar >= Cur_VZ_Z[Rindex][i]) && (zStar <= Cur_VZ_Z[Rindex][i + 1]))
                {
                    vStar = (zStar - Cur_VZ_Z[Rindex][i]) * (Cur_VZ_V[Rindex][i + 1] - Cur_VZ_V[Rindex][i]) / (Cur_VZ_Z[Rindex][i + 1] - Cur_VZ_Z[Rindex][i]) + Cur_VZ_V[Rindex][i];
                    break;
                }
            }
            return vStar;
        }
        //water level => discharge q
        public double insert_zz_qq(int Rindex,double zStar)
        {
            double qStar = 0;
            for (int i = 0; i <= Node_QZ[Rindex] - 2; i++)
            {
                if (zStar < Cur_QZ_Z[Rindex][0])
                {
                    zStar = Cur_QZ_Z[Rindex][0];
                }
                else if (zStar > Cur_QZ_Z[Rindex][Node_QZ[Rindex] - 1])
                {
                    zStar = Cur_QZ_Z[Rindex][Node_QZ[Rindex] - 1];
                }
                if ((zStar >= Cur_QZ_Z[Rindex][i]) && (zStar <= Cur_QZ_Z[Rindex][i + 1]))
                {
                    qStar = (zStar - Cur_QZ_Z[Rindex][i]) * (Cur_QZ_Q[Rindex][i + 1] - Cur_QZ_Q[Rindex][i]) / (Cur_QZ_Z[Rindex][i + 1] - Cur_QZ_Z[Rindex][i]) + Cur_QZ_Q[Rindex][i];
                    break;
                }
            }
            return qStar;
        }
        //discharge q => water level
        public double insert_qq_zz(int Rindex, double qStar)
        {
            double zStar = 0;
            for (int i = 0; i <= Node_QZ[Rindex] - 2; i++)
            {
                if (qStar < Cur_QZ_Q[Rindex][0])
                {
                    qStar = Cur_QZ_Q[Rindex][0];
                }
                else if (qStar > Cur_QZ_Q[Rindex][Node_QZ[Rindex] - 1])
                {
                    qStar = Cur_QZ_Q[Rindex][Node_QZ[Rindex] - 1];
                }
                if ((qStar >= Cur_QZ_Q[Rindex][i]) && (qStar <= Cur_QZ_Q[Rindex][i + 1]))
                {
                    zStar = (qStar - Cur_QZ_Q[Rindex][i]) * (Cur_QZ_Z[Rindex][i + 1] - Cur_QZ_Z[Rindex][i]) / (Cur_QZ_Q[Rindex][i + 1] - Cur_QZ_Q[Rindex][i]) + Cur_QZ_Z[Rindex][i];
                    break;
                }
            }
            return zStar;
        }
    }
}
```
- main function
```
public void Set_Curve()
{
    myCurve.Set_Reservoirs_Num(reservoirs_num);
    for (int i =0;i<reservoirs_num;i++)
    {
        Cur_VZ_V[i] = myCurve.Get_VZ(reservoirs_code[i]).Item1;
        Cur_VZ_Z[i] = myCurve.Get_VZ(reservoirs_code[i]).Item2;
        Node_VZ[i] = myCurve.Get_VZ(reservoirs_code[i]).Item3;
        myCurve.Set_VZ(i, Node_VZ[i], Cur_VZ_V[i], Cur_VZ_Z[i]);

        Cur_QZ_Q[i] = myCurve.Get_QZ(reservoirs_code[i]).Item1;
        Cur_QZ_Z[i] = myCurve.Get_QZ(reservoirs_code[i]).Item2;
        Node_QZ[i] = myCurve.Get_QZ(reservoirs_code[i]).Item3;
        myCurve.Set_QZ(i, Node_QZ[i], Cur_QZ_Q[i], Cur_QZ_Z[i]);

    }
}
```
## 版本二(Suggest)
- Curveclass.cs
```
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WindowsFormsApplication1
{
    class Curveclass
    {
        public DataTable GetDataTable(string str)
        {
            string constr = "server=xx.xxx.xxx.xx;Uid=xx;pwd=xx;database=xx;";
            SqlConnection con = new SqlConnection(constr);
            SqlDataAdapter DA = new SqlDataAdapter(str, con);
            DataTable dt = new DataTable();
            DA.Fill(dt);
            con.Close();
            return dt;
        }
        //利用切片返回多个不同类型数值，考虑一次性将四座水库水位库容关系数值存储于数组中。
        public Tuple<double[], double[],int> get_vz(int RSCD)
        {
            DataTable dt = GetDataTable("SELECT [RZ],[RV] FROM RS_ZVARL_B WHERE RSCD = '" + RSCD + "'ORDER BY PTNO");
            int Node = dt.Rows.Count;
            double[] Cur_V = new double[Node];
            double[] Cur_Z = new double[Node];
            for (int i = 0; i < Node; i++)
            {
                Cur_V[i] = Convert.ToDouble(dt.Rows[i]["RV"]);
                Cur_Z[i] = Convert.ToDouble(dt.Rows[i]["RZ"]);
            }
            var result = Tuple.Create(Cur_V, Cur_Z, Node);
            return result;
        }
        public Tuple<double[], double[], int> get_qz(int RSCD)
        {
            DataTable dt = GetDataTable("SELECT [RZ],[RQ] FROM RS_DCCP_B WHERE RSCD = '" + RSCD + "'ORDER BY PTNO");
            int Node = dt.Rows.Count;
            double[] Cur_Q = new double[Node];
            double[] Cur_Z = new double[Node];
            for (int i = 0; i < Node; i++)
            {
                Cur_Q[i] = Convert.ToDouble(dt.Rows[i]["RQ"]);
                Cur_Z[i] = Convert.ToDouble(dt.Rows[i]["RZ"]);
            }
            var result = Tuple.Create(Cur_Q, Cur_Z, Node);
            return result;
        }
        //volume => water level
        public double insert_vv_zz(double[] cur_V, double[] cur_Z, double vStar, int Node)
        {
            double zStar = 0;
            //int i;
            //for (i = 1; i <= Node - 1; i++)
            //    if (cur_V[i] > vStar) break;
            //zStar = (vStar - cur_V[i-1]) * (cur_Z[i] - cur_Z[i-1]) / (cur_V[i] - cur_V[i-1]) + cur_Z[i-1];
            for (int i = 0; i <= Node - 2; i++)
            {
                if (vStar < cur_V[0])
                {
                    vStar = cur_V[0];
                }
                else if (vStar > cur_V[Node - 1])
                {
                    vStar = cur_V[Node - 1];
                }
                if ((vStar >= cur_V[i]) && (vStar <= cur_V[i + 1]))
                {
                    zStar = (vStar - cur_V[i]) * (cur_Z[i + 1] - cur_Z[i]) / (cur_V[i + 1] - cur_V[i]) + cur_Z[i];
                    break;
                }
            }
            return zStar;
        }
        //water level => volume
        public double insert_zz_vv(double[] cur_V, double[] cur_Z, double zStar, int Node)
        {
            double vStar = 0;
            for (int i = 0; i <= Node - 2; i++)
            {
                if (zStar < cur_Z[0])
                {
                    zStar = cur_Z[0];
                }
                else if (zStar > cur_Z[Node - 1])
                {
                    zStar = cur_Z[Node - 1];
                }
                if ((zStar >= cur_Z[i]) && (zStar <= cur_Z[i + 1]))
                {
                    vStar = (zStar - cur_Z[i]) * (cur_V[i + 1] - cur_V[i]) / (cur_Z[i + 1] - cur_Z[i]) + cur_V[i];
                    break;
                }
            }
            return vStar;
        }
        //water level => discharge q
        public double insert_zz_qq(double[] cur_Q, double[] cur_Z, double zStar, int Node)
        {
            double qStar = 0;
            for (int i = 0; i <= Node - 2; i++)
            {
                if (zStar < cur_Z[0])
                {
                    zStar = cur_Z[0];
                }
                else if (zStar > cur_Z[Node - 1])
                {
                    zStar = cur_Z[Node - 1];
                }
                if ((zStar >= cur_Z[i]) && (zStar <= cur_Z[i + 1]))
                {
                    qStar = (zStar - cur_Z[i]) * (cur_Q[i + 1] - cur_Q[i]) / (cur_Z[i + 1] - cur_Z[i]) + cur_Q[i];
                    break;
                }
            }
            return qStar;
        }
        //discharge q => water level
        public double insert_qq_zz(double[] cur_Q, double[] cur_Z, double qStar, int Node)
        {
            double zStar = 0;
            for (int i = 0; i <= Node - 2; i++)
            {
                if (qStar < cur_Q[0])
                {
                    qStar = cur_Q[0];
                }
                else if (qStar > cur_Q[Node - 1])
                {
                    qStar = cur_Q[Node - 1];
                }
                if ((qStar >= cur_Q[i]) && (qStar <= cur_Q[i + 1]))
                {
                    zStar = (qStar - cur_Q[i]) * (cur_Z[i + 1] - cur_Z[i]) / (cur_Q[i + 1] - cur_Q[i]) + cur_Z[i];
                    break;
                }
            }
            return zStar;
        }
    }
}
```

- main funtion:Use Cureclass funtion in main funtion
```
public void get_Curve_vz()
{
    double[][] cur_vz_v = new double[reservoirs_num][];
    double[][] cur_vz_z = new double[reservoirs_num][];
    int[] Node_vz = new int[reservoirs_num];

    for (int i =0;i<reservoirs_num;i++)
    {
        cur_vz_v[i] = myCurve.get_vz(reservoirs_code[i]).Item1;
        cur_vz_z[i] = myCurve.get_vz(reservoirs_code[i]).Item2;
        Node_vz[i] = myCurve.get_vz(reservoirs_code[i]).Item3;
    }
    double[] b_z = new double[] { 221, 265, 263.3, 254.40 };
    double[] b_v = new double[] { 31100, 13547, 5506.25, 9470 };
    double[] nn_z = new double[4] ;
    double[] nn_v = new double[4];
    for (int i = 0; i < reservoirs_num; i++)
    {
        nn_z[i] = myCurve.insert_zz_vv(cur_vz_v[i], cur_vz_z[i], b_z[i], Node_vz[i]);
        nn_v[i] = myCurve.insert_vv_zz(cur_vz_v[i], cur_vz_z[i], b_v[i], Node_vz[i]);
    }
        
}
public void get_Curve_qz()
{
    double[][] cur_zq_z = new double[reservoirs_num][];
    double[][] cur_zq_q = new double[reservoirs_num][];
    int[] Node_zq = new int[reservoirs_num];
    for (int i = 0; i < reservoirs_num; i++)
    {
        cur_zq_q[i] = myCurve.get_qz(reservoirs_code[i]).Item1;
        cur_zq_z[i] = myCurve.get_qz(reservoirs_code[i]).Item2;
        Node_zq[i] = myCurve.get_qz(reservoirs_code[i]).Item3;
    }
    double[] b_z = new double[] { 221, 266, 263.3, 254.40 };
    double[] b_q = new double[] { 335.8, 2976, 119.8, 336.59 };
    double[] nn_z = new double[4];
    double[] nn_q = new double[4];
    for (int i = 0; i < reservoirs_num; i++)
    {
        nn_q[i] = myCurve.insert_zz_vv(cur_zq_q[i], cur_zq_z[i], b_z[i], Node_zq[i]);
        nn_z[i] = myCurve.insert_vv_zz(cur_zq_q[i], cur_zq_z[i], b_q[i], Node_zq[i]);
    }
}
```

## 版本三
```
class Curveclass
{
    public DataTable GetDataTable(string str)
    {
        string constr = "server=xx.xxx.xxx.xx;Uid=xx;pwd=xx;database=xx;";
        SqlConnection con = new SqlConnection(constr);
        SqlDataAdapter DA = new SqlDataAdapter(str, con);
        DataTable dt = new DataTable();
        DA.Fill(dt);
        con.Close();
        return dt;
    }
    int RSCD_Session_vz = 0;
    int RSCD_Session_qz = 0;
    double[] z_vz;
    double[] v_vz;
    double[] z_qz;
    double[] q_qz;
    double y_vz;
    double y_qz;
    int count_vz, count_qz;
    public double chazhivz(double x, int RSCD)
    {
        if (RSCD != RSCD_Session_vz)
        {
            //Session["RSCD"] = RSCD;
            DataTable dt = GetDataTable("SELECT [RZ],[RV] FROM RS_ZVARL_B WHERE RSCD = '" + RSCD + "'ORDER BY PTNO");
            count_vz = dt.Rows.Count;
            y_vz = 0;
            z_vz = new double[count_vz];
            v_vz = new double[count_vz];
            //int a = dt.Rows.Count;
            //int j = 0;
            //foreach (DataRow row in dt.Rows)
            //{
            //    v[j] = Convert.ToDouble(row["RV"]);
            //    z[j] = Convert.ToDouble(row["RZ"]);
            //    j++;
            //}
            //v = dt.AsEnumerable().Select(r => Convert.ToDouble(r["RV"])).ToArray();
            //z = dt.AsEnumerable().Select(r => Convert.ToDouble(r["RZ"])).ToArray();
            for (int i = 0; i < count_vz; i++)
            {
                v_vz[i] = Convert.ToDouble(dt.Rows[i]["RV"]);
                z_vz[i] = Convert.ToDouble(dt.Rows[i]["RZ"]);
            }
        }
        for (int i = 0; i <= count_vz - 2; i++)
        {
            if (x < v_vz[0])
            {
                x = v_vz[0];
            }
            else if (x > v_vz[count_vz - 1])
            {
                x = v_vz[count_vz - 1];
            }
            if ((x >= v_vz[i]) && (x <= v_vz[i + 1]))
            {
                y_vz = (x - v_vz[i]) * (z_vz[i + 1] - z_vz[i]) / (v_vz[i + 1] - v_vz[i]) + z_vz[i];
            }
        }
        RSCD_Session_vz = RSCD;
        return y_vz;
    }
    public double chazhiqz(double x, int RSCD)
    {
        if (RSCD != RSCD_Session_qz)
        {
            DataTable dt = GetDataTable("SELECT [RZ],[RQ] FROM RS_DCCP_B WHERE RSCD = '" + RSCD + "'ORDER BY PTNO");
            count_qz = dt.Rows.Count;
            y_qz = 0;
            z_qz = new double[count_qz];
            q_qz = new double[count_qz];
            for (int i = 0; i < dt.Rows.Count; i++)
            {
                q_qz[i] = Convert.ToDouble(dt.Rows[i]["RQ"]);
                z_qz[i] = Convert.ToDouble(dt.Rows[i]["RZ"]);
            }
        }
        else
        {
            for (int i = 0; i <= count_qz - 2; i++)
            {
                if (x < z_qz[0])
                {
                    x = z_qz[0];
                }
                else if (x > z_qz[count_qz - 1])
                {
                    x = z_qz[count_qz - 1];
                }
                if ((x >= z_qz[i]) && (x <= z_qz[i + 1]))
                {
                    y_qz = (x - z_qz[i]) * (q_qz[i + 1] - q_qz[i]) / (z_qz[i + 1] - z_qz[i]) + q_qz[i];
                }
            }
        }
        RSCD_Session_qz = RSCD;
        return y_qz;
    }
}
```
